// Copyright ¬© 2023 TDS. All rights reserved. 2023-11-28 Ìôî Ïò§ÌõÑ 05:50 ÍøÄÍøÄüê∑

import CoreData
import SwiftUI

/// VersionÏ≤¥ÌÅ¨ Model
struct VersionCheck: FireStoreCodable {
    let beforeVer: Int
    let rm: String
    let updateDate: String
    let ver: Int
    
    static var mockList: [VersionCheck] = []
}

protocol DataManager {
    func fetchDatas<Station: FireStoreCodable,
                    SubwayLine: FireStoreCodable,
                    LocInfo: FireStoreCodable,
                    Relate: FireStoreCodable>(statType: Station.Type,
                                               subwayLineType: SubwayLine.Type,
                                               locationInfoType: LocInfo.Type,
                                              relateType: Relate.Type,
                                               completion: @escaping (Int, [Station], [SubwayLine], [LocInfo], [Relate]) -> Void)
}

final class RealDataManager: DataManager, FireStoreServiceDelegate {
    private let coreManager = CoreDataManger.shared

    func fetchDatas<Station, SubwayLine, LocInfo, Relate>(statType: Station.Type,
                                                          subwayLineType: SubwayLine.Type,
                                                          locationInfoType: LocInfo.Type,
                                                          relateType: Relate.Type,
                                                          completion: @escaping (Int, [Station], [SubwayLine], [LocInfo], [Relate]) -> Void) where Station: FireStoreCodable, SubwayLine: FireStoreCodable, LocInfo: FireStoreCodable, Relate: FireStoreCodable {
        
        Task {
            // 1. Î≤ÑÏ†Ñ Ï≤¥ÌÅ¨ firestoreÏóêÏÑú VersionCheck Ïª¨Î†âÏÖò Ï°∞ÌöåÌïòÏó¨ ver Í∞í Í∞ÄÏ†∏ÏôÄÏÑú UserDefaultÏùò verÍ∞íÍ≥º ÎπÑÍµêÌïòÍ∏∞.
            let versionData = try? await firestoreFetch(colName: "VersionCheck", docID: "version", type: VersionCheck.self)
            let serverVer: Int = versionData?.ver ?? 1
            let localVer: Int = UserDefaults.standard.integer(forKey: "dataVersion")
            
            Log.trace("üìùüÜö server: \(serverVer) local: \(localVer)")
            
            // 2. localVerÏù¥ serverVerÎ≥¥Îã§ ÎÇÆÏùÑ Ïãú Fetch.
            if serverVer > localVer {
                // Î¨¥Ï°∞Í±¥ FireStoreÏóêÏÑú Fetch. -> FetchÌï¥Ïò® Ï†ïÎ≥¥Î•º CoreDataÏóê Ï†ÄÏû•.
                do {
                    let stationInfos: [Station] = try await firestoreFetchAll(colName: "StationInfo", type: Station.self)
                    let subwayLineInfos: [SubwayLine] = try await firestoreFetchAll(colName: "SubwayLineColor", type: SubwayLine.self)
                    let locInfos: [LocInfo] = try await firestoreFetchAll(colName: "StationLocation", type: LocInfo.self)
                    let relateInfos: [Relate] = try await firestoreFetchAll(colName: "RelateStationInfo", type: Relate.self)
                    
                    // Ìï¥Îãπ Í∞íÏùÑ Î∞õÏïÑÏÑú ÌôîÎ©¥ÏóêÏÑúÎäî Ï≤òÎ¶¨ÌïòÎäî Ï§ëÏù¥Ïñ¥Ïïº ÌïúÎã§. -> setCoreDataÎäî Í∑∏ ÌõÑ Ïã§Ìñâ.
                    completion(serverVer, stationInfos, subwayLineInfos, locInfos, relateInfos)
                    
                } catch let error as NSError {
                    let fetchError = NSError(domain: "FireFetchAll", code: error.code)
                    Log.error(fetchError.localizedDescription)
                    
                    // Î∞∞Ïó¥ 3Í∞úÏ§ë ÌïòÎÇòÎùºÎèÑ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏïàÎì§Ïñ¥Ïò§Î©¥ Ïï±Ïã§ÌñâÏù¥ Î∂àÍ∞ÄÎä•. Ïï±ÏùÑ Ï¢ÖÎ£åÏãúÌÇ§Í≥† Îã§Ïãú Ïã§ÌñâÌïòÍ≤å Ìï¥ÏïºÌïúÎã§.
                    completion(serverVer, [], [], [], [])
                }
                
            } else {
                Log.trace("üìùGetCoreData Î°úÎî©..")
                // Î¨¥Ï°∞Í±¥ coreDataÏóêÏÑú Fetch.
                getCoreData { stationInfo, lineInfo, locInfo, relateInfo in
                    let statInfos = stationInfo as? [Station] ?? []
                    let lineInfos = lineInfo as? [SubwayLine] ?? []
                    let locInfos = locInfo as? [LocInfo] ?? []
                    let relateInfos = relateInfo as? [Relate] ?? []
                    
                    completion(serverVer, statInfos, lineInfos, locInfos, relateInfos)
                }
            }
        }
    }
    
    private func getCoreData(completion: @escaping ([StationInfo], [SubwayLineColor], [StationLocation], [RelateStationInfo]) -> Void) {
        DispatchQueue.main.async { [self] in
            let stationEntity = coreManager.retrieve(type: StationInfoEntity.self)
            let stationInfo = stationEntity.flatMap { info -> [StationInfo] in
                var infos: [StationInfo] = []
                infos.append(.init(subwayId: info.subwayId, subwayNm: info.subwayNm ?? "", statnId: info.statnId, statnNm: info.statnNm ?? ""))
                return infos
            }
            
            let lineEntity = coreManager.retrieve(type: SubwayLineColorEntity.self)
            let lineInfo = lineEntity.flatMap { info -> [SubwayLineColor] in
                var infos: [SubwayLineColor] = []
                infos.append(.init(subwayId: info.subwayId, subwayNm: info.subwayNm ?? "", lineColorHexCode: info.lineColorHexCode ?? ""))
                return infos
            }.sorted { $0.subwayId < $1.subwayId }
            
            let locationEntity = coreManager.retrieve(type: StationLocationEntity.self)
            let locInfo = locationEntity.flatMap { info -> [StationLocation] in
                var infos: [StationLocation] = []
                infos.append(.init(crdntX: info.crdntX, crdntY: info.crdntY, route: info.route ?? "", statnId: info.statnId, statnNm: info.statnNm ?? ""))
                return infos
            }
            
            let relateEntity = coreManager.retrieve(type: RelateStationInfoEntity.self)
            let relateInfo = relateEntity.flatMap { info -> [RelateStationInfo] in
                var infos: [RelateStationInfo] = []
                let relate: RelateStationInfo = .init(statnId: info.statnId, statnNm: info.statnNm ?? "", relateIds: info.relateIds ?? [], relateNms: info.relateNms ?? [])
                
                infos.append(relate)
                
                return infos
            }
            
            completion(stationInfo, lineInfo, locInfo, relateInfo)
            
        }
    }
    
}

final class TestDataManager: DataManager {
    func fetchDatas<Station, SubwayLine, LocInfo, Relate>(statType: Station.Type,
                                                          subwayLineType: SubwayLine.Type,
                                                          locationInfoType: LocInfo.Type,
                                                          relateType: Relate.Type,
                                                          completion: @escaping (Int, [Station], [SubwayLine], [LocInfo], [Relate]) -> Void) where Station: FireStoreCodable, SubwayLine: FireStoreCodable, LocInfo: FireStoreCodable, Relate: FireStoreCodable {
        
        let stationInfos = Station.mockList
        let subwayLineInfos = SubwayLine.mockList
        let locInfos = LocInfo.mockList
        let relateInfos = Relate.mockList
        
        completion(-1, stationInfos, subwayLineInfos, locInfos, relateInfos)
        
    }
    
}
